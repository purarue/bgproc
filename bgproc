#!/usr/bin/env bash
# a bash loop to run things in the background
# uses my evry tool to run commands periodically
# https://github.com/seanbreckenridge/evry

declare ACTION QUIET NO_RECURSIVE
ACTION='loop'
QUIET=
NO_RECURSIVE=

eprintf() {
	((QUIET)) && return
	# shellcheck disable=SC2059
	printf "$@" 1>&2
}

havecmd() {
	local BINARY ERRMSG
	# error if first argument isn't provided
	BINARY="${1:?Must provide command to check}"
	# the commend exists, exit with 0 (success!)
	if command -v "$BINARY" >/dev/null 2>&1; then
		return 0
	else
		# construct error message
		ERRMSG="bgproc requires '$BINARY', could not find that on your \$PATH"
		if [[ -n "$2" ]]; then
			ERRMSG="$ERRMSG. $2"
		fi
		eprintf '%s\n' "$ERRMSG"
		return 1
	fi
}

##### SETUP #####

havecmd evry 'Install it with "cargo install evry"' || exit $?

# if TMPDIR environment variable is set, use that
# set on android/termux
declare -rx TEMP_DIR="${TMPDIR:-/tmp}"

declare -rx LOCKFILE="${BGPROC_LOCKFILE:-${TEMP_DIR}/bgproc.lock}"
declare -rx LOGFILE="${BGPROC_LOGFILE:-${TEMP_DIR}/bgproc.log}"
declare -rx SLEEP_TIME="${BGPROC_SLEEPTIME:-60}"

##### OUT/ERR LOGGING FUNCTIONS #####

declare DATE_FMT="${BGPROC_DATE_FMT:-+%s}"

# both of these accept one argument, which is the message to print

# print a log to STDOUT and append to logfile
printlog() {
	((QUIET)) && return
	printf "$(date "$DATE_FMT"):%s\n" "$1" | tee -a "$LOGFILE"
} && export -f printlog

# print a log to to STDERR, and append to the logfile
# sends a notification if possible
# if the BGPROC_TITLE environment variable is set, uses that
# as the title
# not silenced by the quiet flag
send-error() {
	local title
	title="${BGPROC_TITLE:-'bgproc error'}"
	printf '%s:error:%s\n' "$(date "$DATE_FMT")" "$1" >>"$LOGFILE"
	printf '%s\n' "$1" >&2
	# on linux
	havecmd notify-send 2>/dev/null && notify-send -u critical "${title}" "$1" && return
	# on mac
	havecmd osascript 2>/dev/null && osascript -e "$(printf 'display notification "%s" with title "%s"' "${title}" "$1")" && return
} && export -f send-error

#### CORE FUNCTIONALITY ####

declare -a JOB_DIRS
JOB_DIRS=()

# shorthand to list all jobs
job_list() {
	local FIND_ARGS=()
	((NO_RECURSIVE)) && FIND_ARGS+=(-maxdepth 1)
	FIND_ARGS+=(-type f -name '*.job' -print0)
	for dir in "${JOB_DIRS[@]}"; do
		find -L "${dir}" "${FIND_ARGS[@]}"
	done
}

# print a list of all of the jobs
print_jobs() {
	printlog "Searching for jobs in:"
	for dir in "${JOB_DIRS[@]}"; do
		printlog "${dir}"
	done
	printlog "Job List:"
	while read -r -d $'\0' script; do
		printlog "${script}"
	done < <(job_list)
}

# read in jobs, run each of them
loop_iteration() {
	while read -r -d $'\0' script; do
		bash "${script}" 2>&1
	done < <(job_list)
}

# main, background loop
bgproc_loop() {
	printlog "Sleep duration: ${SLEEP_TIME}"
	printlog "Starting loop..."
	while true; do
		loop_iteration
		sleep "${SLEEP_TIME}"
	done
}

#### PARSE FLAGS ####

# handle flags and run
while getopts 'hodqn' opt; do
	case "${opt}" in
	h)
		printf "Usage: bgproc [-h] [-odqn] [DIR...]\n"
		printf "Runs tasks in the background. Run without flags to start the background loop\n"
		printf "	-n		Don't search directories recursively (add -maxdepth 1)\n"
		printf "	-o		Runs the task loop once\n"
		printf "	-d		Runs the task loop once, in debug mode\n"
		printf "	-q		Quiet mode, silences any logs\n"
		printf "Any additional arguments should be directories which contain '.job' files\n"
		printf "If no directories are provided, searches from the current directory recursively\n"
		printf "See https://github.com/seanbreckenridge/bgproc for more info\n"
		exit 0
		;;
	n)
		NO_RECURSIVE=1
		;;
	o)
		ACTION='once'
		;;
	d)
		ACTION='debug'
		;;
	q)
		QUIET=1
		;;
	*)
		eprintf "Unexpected argument: ${opt}\n"
		exit 1
		;;
	esac
done
shift $((OPTIND - 1))

# If no additional positions were given, assume current directory
case "${#@}" in
0)
	JOB_DIRS+=('.')
	;;
*)
	for dir in "$@"; do
		JOB_DIRS+=("${dir}")
		[[ -e "${dir}" ]] || eprintf "Warning: %s does not exist...\n" "${dir}" >&2
		[[ -d "${dir}" ]] || eprintf "Warning: %s is not a directory...\n" "${dir}" >&2
	done
	;;
esac

##### LOCKFILE #####

check_lockfile() {
	# exit if lock file already exists
	if [[ -e "${LOCKFILE}" ]]; then
		send-error "Lockfile at ${LOCKFILE} already exists, exiting..."
		exit 1
	fi
}

# only check lockfile when running loop, allows the user to run -o or -d
# without having to specify a separate lockfile
if [[ "$ACTION" == 'loop' ]]; then
	check_lockfile
	# delete lockfile when bgproc exits
	cleanup() {
		rm "${LOCKFILE}"
	}
	trap cleanup EXIT
	# create lockfile
	touch "${LOCKFILE}"
fi

##### RUN #####

case "${ACTION}" in
once)
	print_jobs
	loop_iteration
	;;
debug)
	print_jobs
	EVRY_DEBUG=1 loop_iteration
	;;
loop)
	bgproc_loop
	;;
esac
